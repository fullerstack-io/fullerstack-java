package io.kafkaobs.substrates;

import io.humainary.substrates.api.Substrates.*;
import io.kafkaobs.shared.models.MonitorSignal;
import io.kafkaobs.substrates.composer.PipeComposer;
import io.kafkaobs.substrates.sink.SinkBuffer;
import io.kafkaobs.substrates.util.Names;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Unit tests for CortexRuntime using authentic Substrates API.
 *
 * <p>These tests validate Story 4.1 acceptance criteria using the real Substrates API.
 */
class CortexRuntimeTest {

    private CortexRuntime cortex;
    private SinkBuffer sink;

    @BeforeEach
    void setUp() {
        sink = new SinkBuffer(1000);
        cortex = new CortexRuntime(sink);
    }

    @Test
    void shouldProvideCircuitMethod() {
        // AC1: CortexRuntime provides circuit() method compatible with Substrates.Circuit
        // Note: Full Cortex interface implementation (38 methods) deferred to Story 4.5
        Name circuitName = Names.of("kafka.broker.health");
        Circuit circuit = cortex.circuit(circuitName);

        assertThat(circuit).isNotNull();
        assertThat(circuit).isInstanceOf(Circuit.class);
        assertThat(circuit.subject().name().value()).isEqualTo("kafka.broker.health");
    }

    @Test
    void shouldCreateCircuitOnDemand() {
        // AC1: Provides circuit(Name name) method that returns Circuit
        Name circuitName = Names.of("kafka.broker.health");

        Circuit circuit = cortex.circuit(circuitName);

        assertThat(circuit).isNotNull();
        assertThat(circuit).isInstanceOf(Circuit.class);
        assertThat(circuit.subject().name().value()).isEqualTo("kafka.broker.health");
    }

    @Test
    void shouldCacheCircuitsByName() {
        // Verify circuits are cached - same name returns same instance
        Name name = Names.of("test.circuit");

        Circuit circuit1 = cortex.circuit(name);
        Circuit circuit2 = cortex.circuit(name);

        assertThat(circuit1).isSameAs(circuit2);
    }

    @Test
    void shouldCreateConduitWithComposer() {
        // AC2: Circuit provides conduit(Name, Composer) method
        Circuit circuit = cortex.circuit(Names.of("kafka.broker.health"));

        Conduit<Pipe<MonitorSignal>, MonitorSignal> conduit =
            circuit.conduit(Names.of("monitors"), PipeComposer.create(MonitorSignal.class));

        assertThat(conduit).isNotNull();
        assertThat(conduit).isInstanceOf(Conduit.class);
    }

    @Test
    void shouldCreatePerceptFromConduit() {
        // AC3: Conduit provides get(Name subject) that returns percept type P
        Circuit circuit = cortex.circuit(Names.of("kafka.broker.health"));
        Conduit<Pipe<MonitorSignal>, MonitorSignal> conduit =
            circuit.conduit(Names.of("monitors"), PipeComposer.create(MonitorSignal.class));

        Pipe<MonitorSignal> pipe = conduit.get(Names.of("broker-1.jvm.heap"));

        assertThat(pipe).isNotNull();
        assertThat(pipe).isInstanceOf(Pipe.class);
    }

    @Test
    void shouldCachePerceptsBySubject() {
        // Verify percepts are cached - same subject returns same pipe
        Circuit circuit = cortex.circuit(Names.of("test"));
        Conduit<Pipe<MonitorSignal>, MonitorSignal> conduit =
            circuit.conduit(Names.of("monitors"), PipeComposer.create(MonitorSignal.class));

        Name subject = Names.of("test.subject");
        Pipe<MonitorSignal> pipe1 = conduit.get(subject);
        Pipe<MonitorSignal> pipe2 = conduit.get(subject);

        assertThat(pipe1).isSameAs(pipe2);
    }

    @Test
    void shouldSupportMultipleCircuits() {
        // Verify multiple circuits can be created
        Circuit brokerHealth = cortex.circuit(Names.of("kafka.broker.health"));
        Circuit clusterCoord = cortex.circuit(Names.of("kafka.cluster.coordination"));
        Circuit situations = cortex.circuit(Names.of("kafka.situations"));

        assertThat(brokerHealth).isNotSameAs(clusterCoord);
        assertThat(brokerHealth).isNotSameAs(situations);
        assertThat(clusterCoord).isNotSameAs(situations);
    }

    @Test
    void shouldSupportMultipleConduitsPerCircuit() {
        // Verify multiple conduits can be created in same circuit
        Circuit circuit = cortex.circuit(Names.of("kafka.broker.health"));

        Conduit<Pipe<MonitorSignal>, MonitorSignal> monitors =
            circuit.conduit(Names.of("monitors"), PipeComposer.create(MonitorSignal.class));
        Conduit<Pipe<MonitorSignal>, MonitorSignal> resources =
            circuit.conduit(Names.of("resources"), PipeComposer.create(MonitorSignal.class));

        assertThat(monitors).isNotSameAs(resources);
    }

    @Test
    void shouldHaveWorkingSubjectImplementation() {
        // Verify Circuit.subject() returns proper Subject
        Circuit circuit = cortex.circuit(Names.of("test.circuit"));
        Subject subject = circuit.subject();

        assertThat((Object) subject).isNotNull();
        assertThat((Object) subject.name()).isNotNull();
        assertThat(subject.name().value()).isEqualTo("test.circuit");
        assertThat(subject.type()).isEqualTo(Subject.Type.CIRCUIT);
        assertThat((Object) subject.id()).isNotNull();
    }

    @Test
    void shouldShutdownGracefully() {
        // Create some circuits and conduits
        Circuit circuit = cortex.circuit(Names.of("test"));
        circuit.conduit(Names.of("conduit1"), PipeComposer.create(MonitorSignal.class));

        // When
        cortex.shutdown();

        // Then - Should complete without errors
        assertThat(cortex).isNotNull();
    }
}
