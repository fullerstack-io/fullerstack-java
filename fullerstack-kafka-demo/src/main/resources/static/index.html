<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kafka Observability Demo - Substrates API</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            font-size: 14px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #00ff00;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .section {
            background: #000;
            border: 1px solid #00ff00;
            padding: 15px;
            margin-bottom: 15px;
        }

        .section h2 {
            color: #ffff00;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .status {
            display: inline-block;
            padding: 2px 8px;
            margin-left: 10px;
            font-size: 12px;
        }

        .status.connected {
            background: #00ff00;
            color: #000;
        }

        .status.disconnected {
            background: #ff0000;
            color: #fff;
        }

        .signal-line {
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }

        .signal-line:last-child {
            border-bottom: none;
        }

        .overflow {
            color: #ff0000;
            font-weight: bold;
        }

        .normal {
            color: #00ff00;
        }

        .timestamp {
            color: #666;
            font-size: 12px;
        }

        pre {
            background: #111;
            padding: 10px;
            overflow-x: auto;
            border-left: 3px solid #00ff00;
        }

        #signalFeed {
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Kafka Observability Demo - Substrates API
            <span id="wsStatus" class="status disconnected">DISCONNECTED</span>
        </h1>

        <div class="section">
            <h2>WHAT IS THIS?</h2>
            <p>Production-realistic Kafka monitoring using Humainary Substrates API.</p>
            <p>A separate producer process exposes JMX metrics. This app monitors those metrics and emits <strong>semiotic signals</strong>.</p>
        </div>

        <div class="section">
            <h2>CURRENT STATE</h2>
            <div id="currentState">
                <p>Monitoring: <strong>producer-1</strong> buffer via JMX (localhost:11001)</p>
                <p>Poll interval: 10 seconds</p>
                <p>Threshold: OVERFLOW when buffer &gt;95% full</p>
                <p>Total signals received: <span id="signalCount">0</span></p>
            </div>
        </div>

        <div class="section">
            <h2>LATEST SIGNAL</h2>
            <div id="latestSignal">
                <p class="timestamp">Waiting for first signal...</p>
            </div>
        </div>

        <div class="section">
            <h2>SIGNAL HISTORY (last 10)</h2>
            <div id="signalFeed">
                <p class="timestamp">No signals yet</p>
            </div>
        </div>

        <div class="section">
            <h2>WHAT SIGNALS MEAN</h2>
            <pre>
Queue.PUT       → Normal: buffer accepting messages, no pressure
Queue.OVERFLOW  → Problem: buffer &gt;95% full, producer will block soon

Traditional monitoring: Shows metric "buffer-available-bytes: 1638400"
                       YOU must interpret what that number means

Semiotic monitoring: Shows "Queue.OVERFLOW"
                    System UNDERSTANDS the problem
            </pre>
        </div>

        <div class="section">
            <h2>HOW TO TRIGGER OVERFLOW</h2>
            <pre>
Producer is currently running at 10,000 msg/sec (very high rate).
If buffer fills faster than Kafka can drain → OVERFLOW signal.

To see normal signals, restart producer at slower rate:
  RATE=10 java -Dcom.sun.management.jmxremote.port=11001 \
    -Dcom.sun.management.jmxremote.authenticate=false \
    -Dcom.sun.management.jmxremote.ssl=false \
    -Dcom.sun.management.jmxremote.rmi.port=11001 \
    -cp target/kafka-observability-demo.jar \
    io.fullerstack.kafka.demo.StandaloneProducer
            </pre>
        </div>
    </div>

    <script>
        let ws;
        let signalCount = 0;
        const maxHistory = 10;
        const signalHistory = [];

        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                document.getElementById('wsStatus').textContent = 'CONNECTED';
                document.getElementById('wsStatus').className = 'status connected';
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'signal') {
                    handleSignal(data);
                }
            };

            ws.onerror = () => {
                document.getElementById('wsStatus').textContent = 'ERROR';
                document.getElementById('wsStatus').className = 'status disconnected';
            };

            ws.onclose = () => {
                document.getElementById('wsStatus').textContent = 'DISCONNECTED';
                document.getElementById('wsStatus').className = 'status disconnected';
                setTimeout(connect, 3000);
            };
        }

        function handleSignal(data) {
            const { entityId, data: signalData } = data;
            const signalStr = signalData.signal || '';
            const timestamp = new Date().toLocaleTimeString();

            signalCount++;
            document.getElementById('signalCount').textContent = signalCount;

            // Update latest
            const isOverflow = signalStr.includes('OVERFLOW');
            const cssClass = isOverflow ? 'overflow' : 'normal';

            document.getElementById('latestSignal').innerHTML = `
                <p class="timestamp">${timestamp}</p>
                <p class="${cssClass}">Entity: ${entityId}</p>
                <p class="${cssClass}">Signal: ${signalStr}</p>
                ${isOverflow ? '<p class="overflow">⚠️  BUFFER OVERFLOW - Producer will block soon!</p>' : '<p class="normal">✓ Normal operation - buffer healthy</p>'}
            `;

            // Add to history
            signalHistory.unshift({ timestamp, entityId, signalStr, cssClass });
            if (signalHistory.length > maxHistory) {
                signalHistory.pop();
            }

            // Render history
            const feed = document.getElementById('signalFeed');
            feed.innerHTML = signalHistory.map(s =>
                `<div class="signal-line">
                    <span class="timestamp">${s.timestamp}</span>
                    <span class="${s.cssClass}"> ${s.entityId}: ${s.signalStr}</span>
                </div>`
            ).join('');
        }

        connect();
    </script>
</body>
</html>
